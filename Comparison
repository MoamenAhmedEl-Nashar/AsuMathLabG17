class matrix
{
    public:
    int rows;
    int columns;
    string mName,errorHandler;

    double** element;
    int getRows()
    {
        return rows;
    }

    int getColumns()
    {
        return columns;
    }
     void setRows (int r)
    {
        rows=r;
    }
    void setColumns (int c)
    {
        columns=c;
    }

    /*double** getElementArray() //if we make element private
    {
        return element;
    }*/


    matrix()
    {
      rows=0;
      columns=0;
	  mName="NULL" ;
    }

    //copy constructor
    matrix(const matrix &mCopied)
    {
        rows=mCopied.rows;
        columns=mCopied.columns;
        mName=mCopied.mName;

        if(rows==0&&columns==0)
            element=NULL;
        else
        {
        element=new double*[rows];
        for(int i=0;i<rows;i++)
        {
            element[i]=new double[columns];
        }
            for(int i=0;i<rows;i++)
            {
                for(int j=0;j<columns;j++)
                {
                    element[i][j]=mCopied.element[i][j];
                }
            }
        }

    }

    void setName(string name)
    {
        this->mName = name;
    }

    string getName()
    {
        return mName;
    }
    double* getElement(int elementRow, int elementColumn)
    {
        return this->element[elementRow, elementColumn];
    }

    void initialling(string mName,string mString) // give me string wana azzabat isa
    {
        this->mName=mName;
        stringstream ss(mString);
        string token;
        while(getline(ss, token, ';'))
        {
            this->rows++;
            stringstream sn;
            sn<<token;
            double in;
            while( sn >> in)
            {
                if(rows==1)
                    this->columns++;
            }

        }
    //----------------------------------------------------
        element = new double*[rows];
        for(int i = 0; i < rows; ++i)
        element[i] = new double[columns];
        int p=0, q=0;
        stringstream ss3(mString);
        string token1;
        while(getline(ss3, token1, ';'))
        {
            stringstream ss1(token1);
            string token2;
            while(ss1>>token2)
            {
                element[p][q] = StringToDouble(token2); //p rows --- q columns
                q++;
            }
            q=0;
            p++;
        }
    }
    void update(string mName,string mString)
    {

        setRows(0);
        setColumns(0);
        for(int i=0;i<rows;i++)
		{
			delete[] element[i];
		}
		delete[] element;
		initialling(mName,mString);

    }

    void initialling(int rows1, int columns1)//give rows and columns wana azzabat isa
    {
        this->columns = columns1;
        this->rows = rows1;
        element=new double* [rows1];
        for(int i=0; i<rows1;i++)
            element[i]=new double[columns1];
    }

    void setElement(int elementRow, int elementColumn, double elementValue) // modify the main object's 2d array
    {
        element[elementRow][elementColumn] = elementValue;
    }

     void getTranspose(matrix &x)
    {

        this->initialling(x.columns, x.rows);
        for(int m=0 ; m<(this->getRows()) ; m++)
        {
            for(int n=0 ; n<(this->getColumns()) ; n++)
            {
                this->setElement(m,n,x.element[n][m]);
            }
        }

    }

    void subMatrix(matrix& x,int elementRow, int elementColumn)
    {
        this->initialling((x.rows)-1, (x.columns)-1);
        for(int i=0,m=0 ; i<x.rows,m<(this->getRows()) ; i++)
        {
            if(i == elementRow) continue;
            else
            {
                for(int j=0,n=0 ; j<x.columns,n<(this->getColumns()) ; j++)
                {
                    if(j == elementColumn) continue;
                    else
                    {
                        this->setElement(m,n,x.element[i][j]);
                        n++;
                    }
                }
                m++;
            }
        }

    }

    //--------------------------------------------------------------------
	double getDeterminant() {
		if(rows==columns){
		int i, j, k;
		double factor;
		double temp;
		matrix a(*this) ;
		int counti=0;
			int m=this->rows ;
	for(i = 0; i < m - 1; i++)
	{
		/* Elementary Row Operation I */
		if(a.element[i][i] == 0)
		{
			for(k = i; k < m; k++)
			{
				if(a.element[k][i] != 0)
				{
					for(j = 0; j < m; j++)
					{
						temp = a.element[i][j];
						a.element[i][j] = a.element[k][j];
						a.element[k][j] = temp;
					}
				k = m;
				}
			}
			counti++;
		}
		/* Elementary Row Operation III */
		if(a.element[i][i] != 0)
		{
			for(k = i + 1; k < m; k++)
			{
				factor = -1.0 * a.element[k][i] /  a.element[i][i];
				for(j = i; j < m; j++)
				{
					a.element[k][j] = a.element[k][j] + (factor * a.element[i][j]);
				}
			}
		}
	}

	/* Display upper triangular matrix */

	temp = 1.0;


	for(i = 0; i < m; i++)
	{
		temp *= a.element[i][i];
	}


	if(counti % 2 == 0)
	{
		return temp;;
	}
	else
	{
		return -1*temp ;
	}
		}
		else return 0;

}
		//--------------------------------------------------------------------------
    void getInverse(matrix &x)
    {
	matrix z;
        double detObj = x.getDeterminant();
        this->initialling(x.rows, x.columns);
	z.initialling(x.rows, x.columns);
	matrix sub;
	int nozero=0;
        for(int i=0 ; i<x.rows ; i++)
        {
            for(int j=0 ; j<x.columns ; j++)
            {
		sub.subMatrix(x,i,j);
                double minor = sub.getDeterminant();
				if(minor==0){
					nozero=nozero/ detObj;
					z.setElement(i,j,nozero);
				}
				else{
			if((i+j)%2!=0) minor *= -1;




                minor = minor / detObj;
                z.setElement(i,j,minor);
				}
            }

        }
        this->getTranspose(z);
    }
	void inversePerElement(matrix &x)
	{
		this->initialling(x.rows, x.columns);
		for (int m = 0; m<(this->getRows()); m++)
		{
			for (int n = 0; n<(this->getColumns()); n++)
			{
				if(x.element[m][n]!=0)
					this->setElement(m, n, 1/(x.element[m][n]));
				else
					this->errorHandler="Error There's a zero element in the matrix"; //this is to handle 1/0 error me7taga tet3addel tab3an
			}
		}
	}

    void add(matrix& x, matrix& y,int old=0)
    {

         if(old==0)
        this->initialling(x.rows, x.columns);
        for(int i=0 ; i< (this->rows) ; i++)
        {
            for(int j=0 ; j< (this->columns) ; j++)
            {
                element[i][j] = x.element[i][j] + y.element[i][j];
            }
        }

    }

     void sub(matrix& x, matrix& y,int old=0)
    {
        if(old==0)
        this->initialling(x.rows, x.columns);
        for(int i=0 ; i< (this->rows) ; i++)
        {
            for(int j=0 ; j< (this->columns) ; j++)
            {
                element[i][j] = x.element[i][j] - y.element[i][j];
            }
        }

    }

    void mult(matrix &x,matrix &y,int asg=0)//remember to handle errors of dimension
	{
		//declaration the output(returned) matrix
		if(asg==0)
        this->initialling(x.rows, y.columns);//use constructor instead
        double** temp;
        if(asg==1)
        {
            temp=new double*[x.rows];
            for(int w=0;w<x.rows;w++)
                temp[w]=new double [x.columns];
            for(int w=0;w<x.rows;w++)
                for(int q=0;q<x.columns;q++)
                temp[w][q]=x.element[w][q];
        }
        if(asg==2)
        {
            temp=new double*[y.rows];
            for(int w=0;w<y.rows;w++)
                temp[w]=new double [y.columns];
            for(int w=0;w<y.rows;w++)
                for(int q=0;q<y.columns;q++)
                temp[w][q]=y.element[w][q];
        }

        //filling the matrix with valus
		for(int i=0;i<rows;i++)
			for(int j=0; j<columns ; j++)
				element[i][j]=0;
		for (int i = 0; i < x.rows; i++)
		{
			for (int j = 0; j < y.columns; j++)
			{
				for (int k = 0; k < y.rows; k++)
				{
				    if(asg==0)
					    element[i][j] += x.element[i][k] * y.element[k][j]; //use setElement function instead
					else if(asg==1)
                        element[i][j] += temp[i][k] * y.element[k][j];
                    else if(asg==2)
                        element[i][j] += x.element[i][k] * temp[k][j];
				}
			}
		}

	}

	void div(matrix &x, matrix &y)
	{
	    matrix inverseDenom;
        inverseDenom.getInverse(y);
        this->initialling(x.rows, inverseDenom.getColumns());
        this->mult(x,inverseDenom);


	}
	//trigonometric functions , any trigonometric function for a matrix is started with 'M'
	//sin functions --> sin , sind , asin , asind , sinh , asinh
	void Msin(matrix &x)
	{
		this->initialling(x.rows, x.columns);
		for (int m = 0; m<(this->getRows()); m++)
		{
			for (int n = 0; n<(this->getColumns()); n++)
			{
				this->setElement(m, n, sin(x.element[m][n]));
			}
		}
	}
	void Msind(matrix &x)
	{
		this->initialling(x.rows, x.columns);
		for (int m = 0; m<(this->getRows()); m++)
		{
			for (int n = 0; n<(this->getColumns()); n++)
			{
				this->setElement(m, n, sind(x.element[m][n]));
			}
		}
	}
	void Masin(matrix &x)  // error handling
	{
		this->initialling(x.rows, x.columns);
		for (int m = 0; m<(this->getRows()); m++)
		{
			for (int n = 0; n<(this->getColumns()); n++)
			{
				this->setElement(m, n, asin(x.element[m][n]));
			}
		}
	}
	void Masind(matrix &x)
	{
		this->initialling(x.rows, x.columns);
		for (int m = 0; m<(this->getRows()); m++)
		{
			for (int n = 0; n<(this->getColumns()); n++)
			{
				this->setElement(m, n, (asind(x.element[m][n])));
			}
		}
	}
	void Msinh(matrix &x)
	{
		this->initialling(x.rows, x.columns);
		for (int m = 0; m<(this->getRows()); m++)
		{
			for (int n = 0; n<(this->getColumns()); n++)
			{
				this->setElement(m, n, sinh(x.element[m][n]));
			}
		}
	}
	void Masinh(matrix &x)  // error handling
	{
		this->initialling(x.rows, x.columns);
		for (int m = 0; m<(this->getRows()); m++)
		{
			for (int n = 0; n<(this->getColumns()); n++)
			{
				this->setElement(m, n, asinh(x.element[m][n]));
			}
		}
	}
	//cos functions --> cos , cosd, acos , acosd ,cosh, acosh
	void Mcos(matrix &x)
	{
		this->initialling(x.rows, x.columns);
		for (int m = 0; m<(this->getRows()); m++)
		{
			for (int n = 0; n<(this->getColumns()); n++)
			{
				this->setElement(m, n, cos(x.element[m][n]));
			}
		}
	}
	void Mcosd(matrix &x)
	{
		this->initialling(x.rows, x.columns);
		for (int m = 0; m<(this->getRows()); m++)
		{
			for (int n = 0; n<(this->getColumns()); n++)
			{
				this->setElement(m, n, cosd(x.element[m][n]));
			}
		}
	}
	void Macos(matrix &x)  // error handling
	{
		this->initialling(x.rows, x.columns);
		for (int m = 0; m<(this->getRows()); m++)
		{
			for (int n = 0; n<(this->getColumns()); n++)
			{
				this->setElement(m, n, acos(x.element[m][n]));
			}
		}
	}
	void Macosd(matrix &x)
	{
		this->initialling(x.rows, x.columns);
		for (int m = 0; m<(this->getRows()); m++)
		{
			for (int n = 0; n<(this->getColumns()); n++)
			{
				this->setElement(m, n, (acosd(x.element[m][n])));
			}
		}
	}
	void Mcosh(matrix &x)
	{
		this->initialling(x.rows, x.columns);
		for (int m = 0; m<(this->getRows()); m++)
		{
			for (int n = 0; n<(this->getColumns()); n++)
			{
				this->setElement(m, n, cosh(x.element[m][n]));
			}
		}
	}
	void Macosh(matrix &x)  // error handling
	{
		this->initialling(x.rows, x.columns);
		for (int m = 0; m<(this->getRows()); m++)
		{
			for (int n = 0; n<(this->getColumns()); n++)
			{
				this->setElement(m, n, acosh(x.element[m][n]));
			}
		}
	}
	// tan functions --> tan,tand,atan,atand,tanh,atanh
	void Mtan(matrix &x) //error handling
	{
		this->initialling(x.rows, x.columns);
		for (int m = 0; m<(this->getRows()); m++)
		{
			for (int n = 0; n<(this->getColumns()); n++)
			{
				this->setElement(m, n, tan(x.element[m][n]));
			}
		}
	}
	void Mtand(matrix &x)//error handling
	{
		this->initialling(x.rows, x.columns);
		for (int m = 0; m<(this->getRows()); m++)
		{
			for (int n = 0; n<(this->getColumns()); n++)
			{
				this->setElement(m, n, tand(x.element[m][n]));
			}
		}
	}
	void Matan(matrix &x)  // error handling
	{
		this->initialling(x.rows, x.columns);
		for (int m = 0; m<(this->getRows()); m++)
		{
			for (int n = 0; n<(this->getColumns()); n++)
			{
				this->setElement(m, n, atan(x.element[m][n]));
			}
		}
	}
	void Matand(matrix &x)
	{
		this->initialling(x.rows, x.columns);
		for (int m = 0; m<(this->getRows()); m++)
		{
			for (int n = 0; n<(this->getColumns()); n++)
			{
				this->setElement(m, n, (atand(x.element[m][n])));
			}
		}
	}
	void Mtanh(matrix &x)
	{
		this->initialling(x.rows, x.columns);
		for (int m = 0; m<(this->getRows()); m++)
		{
			for (int n = 0; n<(this->getColumns()); n++)
			{
				this->setElement(m, n, tanh(x.element[m][n]));
			}
		}
	}
	void Matanh(matrix &x)  // error handling
	{
		this->initialling(x.rows, x.columns);
		for (int m = 0; m<(this->getRows()); m++)
		{
			for (int n = 0; n<(this->getColumns()); n++)
			{
				this->setElement(m, n, atanh(x.element[m][n]));
			}
		}
	}
	// csc functions --> csc , cscd ,acsc ,acscd ,csch ,acsch
	void Mcsc(matrix &x)
	{
		this->initialling(x.rows, x.columns);
		for (int m = 0; m<(this->getRows()); m++)
		{
			for (int n = 0; n<(this->getColumns()); n++)
			{
				this->setElement(m, n, csc(x.element[m][n]));
			}
		}
	}
	void Mcscd(matrix &x)
	{
		this->initialling(x.rows, x.columns);
		for (int m = 0; m<(this->getRows()); m++)
		{
			for (int n = 0; n<(this->getColumns()); n++)
			{
				this->setElement(m, n, cscd(x.element[m][n]));
			}
		}
	}
	void Macsc(matrix &x)  // error handling
	{
		this->initialling(x.rows, x.columns);
		for (int m = 0; m<(this->getRows()); m++)
		{
			for (int n = 0; n<(this->getColumns()); n++)
			{
				this->setElement(m, n, acsc(x.element[m][n]));
			}
		}
	}
	void Macscd(matrix &x)
	{
		this->initialling(x.rows, x.columns);
		for (int m = 0; m<(this->getRows()); m++)
		{
			for (int n = 0; n<(this->getColumns()); n++)
			{
				this->setElement(m, n, (acscd(x.element[m][n])));
			}
		}
	}
	void Mcsch(matrix &x)
	{
		this->initialling(x.rows, x.columns);
		for (int m = 0; m<(this->getRows()); m++)
		{
			for (int n = 0; n<(this->getColumns()); n++)
			{
				this->setElement(m, n, csch(x.element[m][n]));
			}
		}
	}
	void Macsch(matrix &x)  // error handling
	{
		this->initialling(x.rows, x.columns);
		for (int m = 0; m<(this->getRows()); m++)
		{
			for (int n = 0; n<(this->getColumns()); n++)
			{
				this->setElement(m, n, acsch(x.element[m][n]));
			}
		}
	}
	//sec functions --> sec ,secd ,asec, asecd ,sech ,asech
	void Msec(matrix &x)
	{
		this->initialling(x.rows, x.columns);
		for (int m = 0; m<(this->getRows()); m++)
		{
			for (int n = 0; n<(this->getColumns()); n++)
			{
				this->setElement(m, n, sec(x.element[m][n]));
			}
		}
	}
	void Msecd(matrix &x)
	{
		this->initialling(x.rows, x.columns);
		for (int m = 0; m<(this->getRows()); m++)
		{
			for (int n = 0; n<(this->getColumns()); n++)
			{
				this->setElement(m, n, secd(x.element[m][n]));
			}
		}
	}
	void Masec(matrix &x)  // error handling
	{
		this->initialling(x.rows, x.columns);
		for (int m = 0; m<(this->getRows()); m++)
		{
			for (int n = 0; n<(this->getColumns()); n++)
			{
				this->setElement(m, n, asec(x.element[m][n]));
			}
		}
	}
	void Masecd(matrix &x)
	{
		this->initialling(x.rows, x.columns);
		for (int m = 0; m<(this->getRows()); m++)
		{
			for (int n = 0; n<(this->getColumns()); n++)
			{
				this->setElement(m, n, (asecd(x.element[m][n])));
			}
		}
	}
	void Msech(matrix &x)
	{
		this->initialling(x.rows, x.columns);
		for (int m = 0; m<(this->getRows()); m++)
		{
			for (int n = 0; n<(this->getColumns()); n++)
			{
				this->setElement(m, n, sech(x.element[m][n]));
			}
		}
	}
	void Masech(matrix &x)  // error handling
	{
		this->initialling(x.rows, x.columns);
		for (int m = 0; m<(this->getRows()); m++)
		{
			for (int n = 0; n<(this->getColumns()); n++)
			{
				this->setElement(m, n, asech(x.element[m][n]));
			}
		}
	}
	// cot functions cot , cotd , acot ,acotd ,coth ,acoth
	void Mcot(matrix &x)
	{
		this->initialling(x.rows, x.columns);
		for (int m = 0; m<(this->getRows()); m++)
		{
			for (int n = 0; n<(this->getColumns()); n++)
			{
				this->setElement(m, n, cot(x.element[m][n]));
			}
		}
	}
	void Mcotd(matrix &x)
	{
		this->initialling(x.rows, x.columns);
		for (int m = 0; m<(this->getRows()); m++)
		{
			for (int n = 0; n<(this->getColumns()); n++)
			{
				this->setElement(m, n, cotd(x.element[m][n]));
			}
		}
	}
	void Macot(matrix &x)  // error handling
	{
		this->initialling(x.rows, x.columns);
		for (int m = 0; m<(this->getRows()); m++)
		{
			for (int n = 0; n<(this->getColumns()); n++)
			{
				this->setElement(m, n, acot(x.element[m][n]));
			}
		}
	}
	void Macotd(matrix &x)
	{
		this->initialling(x.rows, x.columns);
		for (int m = 0; m<(this->getRows()); m++)
		{
			for (int n = 0; n<(this->getColumns()); n++)
			{
				this->setElement(m, n, (acotd(x.element[m][n])));
			}
		}
	}
	void Mcoth(matrix &x)
	{
		this->initialling(x.rows, x.columns);
		for (int m = 0; m<(this->getRows()); m++)
		{
			for (int n = 0; n<(this->getColumns()); n++)
			{
				this->setElement(m, n, coth(x.element[m][n]));
			}
		}
	}
	void Macoth(matrix &x)  // error handling
	{
		this->initialling(x.rows, x.columns);
		for (int m = 0; m<(this->getRows()); m++)
		{
			for (int n = 0; n<(this->getColumns()); n++)
			{
				this->setElement(m, n, acoth(x.element[m][n]));
			}
		}
	}

	//end trignometric functions


	//element wise operators
	void addEL(matrix &x, double y)//EL stands for Element Wise  A+2 or A+1
	{
		this->initialling(x.rows, x.columns);
		for (int m = 0; m<(this->getRows()); m++)
		{
			for (int n = 0; n<(this->getColumns()); n++)
			{
				this->setElement(m, n, (x.element[m][n])+y);
			}
		}
	}
	void subEL(matrix &x, double y)//EL stands for Element Wise  A-2 or A-1
	{
		this->initialling(x.rows, x.columns);
		for (int m = 0; m<(this->getRows()); m++)
		{
			for (int n = 0; n<(this->getColumns()); n++)
			{
				this->setElement(m, n, (x.element[m][n])-y);
			}
		}
	}

	void multEL(matrix &x, double y)//EL stands for Element Wise  A.*2 or A.*1  same as A*2 or A*1
	{
		this->initialling(x.rows, x.columns);
		for (int m = 0; m<(this->getRows()); m++)
		{
			for (int n = 0; n<(this->getColumns()); n++)
			{
				this->setElement(m, n,(x.element[m][n])*y);
			}
		}
	}
	void divEL(matrix &x, double y)//EL stands for Element Wise A./2 or A./1  same as A/2 or A/1
	{
		this->initialling(x.rows, x.columns);
		for (int m = 0; m<(this->getRows()); m++)
		{
			for (int n = 0; n<(this->getColumns()); n++)
			{
				this->setElement(m, n, (x.element[m][n])/y);
			}
		}
	}
	void multEL(matrix &x, matrix& y)//EL stands for Element Wise A.*B  or  A.* c etc..
	{
		this->initialling(x.rows, x.columns);
		for (int m = 0; m<(this->getRows()); m++)
		{
			for (int n = 0; n<(this->getColumns()); n++)
			{
				this->setElement(m, n, (x.element[m][n])*(y.element[m][n]));
			}
		}
	}
	void divEL(matrix &x, matrix& y)//EL stands for Element Wise A./B  or  A./c etc..
	{
		this->initialling(x.rows, x.columns);
		for (int m = 0; m<(this->getRows()); m++)
		{
			for (int n = 0; n<(this->getColumns()); n++)
			{
				this->setElement(m, n, (x.element[m][n])/(y.element[m][n]));
			}
		}
	}
	//end element wise operators
	///// farouk
	    void multforpower(matrix &x,matrix &y)           //multiplication for square matrices and assigning the result in the first matrix
	{

        this->initialling(x.rows, x.columns);

		for(int i=0;i<rows;i++)
			for(int j=0; j<columns ; j++)
				element[i][j]=0;
		for (int i = 0; i < x.rows; i++)
		{
			for (int j = 0; j < x.columns; j++)
			{
				for (int k = 0; k < x.rows; k++)
				{

                    element[i][j] += x.element[i][k] * y.element[k][j];
				}
			}
		}
		for (int i = 0; i < x.rows; i++)
            for (int j = 0; j < y.columns; j++)
                x.element[i][j] = element[i][j];

	}
	void identityMatrix()                                      //identity matrix I
	{

		for(int i=0;i<rows;i++)
			for(int j=0; j<columns ; j++)
				element[i][j]= (i == j);
	}

    void power(matrix &x, double power)                  //matrix power
	{
	    if(x.rows == x.columns)                          //must be square matrix
        {
            int mod = power*10;                          //To check if power is fractional
            if(power == 0)                               //produce identity matrix if power = 0
            {
                this->initialling(x.rows,x.columns);
                this->identityMatrix();
            }
            else if(mod % 10 != 0)                       //To check if power is fractional
            {
                if(x.rows == 1)                          //Support fractional power for 1*1 matrix only
                {
                    double y = pow(x.element[0][0], power);
                    this->initialling(1,1);
                    element[0][0] = y;
                }
                else
                    errorHandler = "Error: Fraction power is supported in 1*1 matrix only.";
            }
            else
            {
                int intPower;
                if(power < 0)
                  intPower = (int)abs(power);
                else
                    intPower = (int)power;
                matrix y;                                         //Two matrices to be used in calculation
                y.initialling(x.rows, x.columns);
                matrix temp;
                temp.initialling(x.rows,x.columns);
                for(int i=0;i<temp.rows;i++)
                        for(int j=0; j<temp.columns ; j++)
                            temp.element[i][j] = x.element[i][j];
                y.identityMatrix();
                while (intPower > 0)                             //matrix power by exponentiation by squaring algorithm
                {
                    if (intPower % 2 == 1)
                    {
                    this->multforpower(y,temp);
                    }

                    this->multforpower(temp, temp);
                    intPower /= 2;


                }
                this->initialling(y.rows,y.columns);              //Get inverse if  power is negative
                if(power < 0)
                {
                    this->getInverse(y);

                }
                else
                {
                    for(int i=0;i<rows;i++)
                        for(int j=0; j<columns ; j++)
                            element[i][j] = y.element[i][j];
                }

            }
        }

            else
                errorHandler = "Error: for A^x, A must be a square matrix.";

	}
	void elementWisePower(matrix &x, double power)                  //matrix power
	{
            int mod = power*10;                          //To check if power is fractional
            if(power == 0)                               //produce identity matrix if power = 0
            {
                this->initialling(x.rows,x.columns);
                 for(int i=0;i<rows;i++)
                        for(int j=0; j<columns ; j++)
                            element[i][j] = 1;
            }
            else if(mod % 10 != 0)                       //To check if power is fractional
            {
                this->initialling(x.rows,x.columns);
                 for(int i=0;i<rows;i++)
                        for(int j=0; j<columns ; j++)
                            element[i][j] = pow(x.element[i][j],power);
            }
            else
            {
                int intPower;
                if(power < 0)
                  intPower = (int)abs(power);
                else
                  intPower = (int)power;
                matrix y;                                         //Two matrices to be used in calculation
                y.initialling(x.rows, x.columns);
                for(int i=0;i<y.rows;i++)
                        for(int j=0; j<y.columns ; j++)
                            y.element[i][j] = 1;
                matrix temp;
                temp.initialling(x.rows,x.columns);
                for(int i=0;i<temp.rows;i++)
                        for(int j=0; j<temp.columns ; j++)
                            temp.element[i][j] = x.element[i][j];

                while (intPower > 0)                             //matrix power by exponentiation by squaring algorithm
                {
                    if (intPower % 2 == 1)
                    {
                    for(int i=0;i<temp.rows;i++)
                        for(int j=0; j<temp.columns ; j++)
                            y.element[i][j] = y.element[i][j]*temp.element[i][j];
                    }

                    for(int i=0;i<temp.rows;i++)
                        for(int j=0; j<temp.columns ; j++)
                            temp.element[i][j] = temp.element[i][j]*temp.element[i][j];
                    intPower /= 2;


                }
                this->initialling(y.rows,y.columns);              //Get inverse if  power is negative
                if(power < 0)
                {
                    this->inversePerElement(y);

                }
                else
                {
                    for(int i=0;i<rows;i++)
                        for(int j=0; j<columns ; j++)
                            element[i][j] = y.element[i][j];
                }

            }

	}
	void logMatrix(matrix &x)
	{
	    this->initialling(x.rows,x.columns);
	    for(int i=0;i<rows;i++)
                        for(int j=0; j<columns ; j++)
                            element[i][j] = log(x.element[i][j]);
	}
	void log10Matrix(matrix &x)
	{
	    this->initialling(x.rows,x.columns);
	    for(int i=0;i<rows;i++)
                        for(int j=0; j<columns ; j++)
                            element[i][j] = log10(x.element[i][j]);
	}
	void sqrtMatrix(matrix &x)
	{
	    this->initialling(x.rows,x.columns);
	    for(int i=0;i<rows;i++)
                        for(int j=0; j<columns ; j++)
                            element[i][j] = sqrt(x.element[i][j]);
	}
	void expMatrix(matrix &x)
	{
	    this->initialling(x.rows,x.columns);
	    for(int i=0;i<rows;i++)
                        for(int j=0; j<columns ; j++)
                            element[i][j] = exp(x.element[i][j]);
	}
	//////
	void print()
	{
		if(errorHandler=="Error There's a zero element in the matrix" ||
     errorHandler=="Error The determinant of this matrix is eual to zero")
			cout<<errorHandler;
		else
		{
		   /* if(mName[0]!='@' && mName[0]!='&' &&
          mName[0]!='#' && mName[0]!='_' )*/
          {
             cout << endl;
			cout << mName << " = " << endl;
			for (int i = 0; i<rows; i++)
			{
				for (int j = 0; j<columns; j++)
				{
					cout << "\t" << element[i][j];
				}
				cout << endl;
			}
          }

		}
		cout<<endl;
	}

	~matrix()
	{
		for(int i=0;i<rows;i++)
		{
			delete[] element[i];
		}
		delete[] element;
		element = NULL;

	}
