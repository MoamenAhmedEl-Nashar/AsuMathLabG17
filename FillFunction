void sFill(matrix mSoph, string mString)
{
	int lastPos = 0;
	string temp;
	matrix tempM;
	int flag = 0, OBCounter = 0, CBFlag = 0;
	int OBColumnCounter[100] = { 0 }, OBRowCounter[100] = { 0 }, OBColumnReset = 0, OBRowReset = 0;
	for (int r = 0; r < mSoph.rows; r++)
	{
		for (int c = 0; c < mSoph.columns; c++)
		{
			if (mSoph.element[r][c].isFilled == 1) continue;

			temp = mString.substr(lastPos, 1);
			//If character is found
			if ((int(temp[0]) >= 65 && int(temp[0]) <= 90) || (int(temp[0]) >= 97 && int(temp[0]) <= 122))
			{
				//If it's a stored matrix
				int index = memoryCheck(temp);
				if (index != -1)
				{
					//B
					//memory.p[index]
					for (int rs = 0; rs < memory.p[index].rows; rs++)
					{
						for (int cs = 0; cs < memory.p[index].columns; cs++)
						{
							mSoph.element[r + rs][c + cs].value = memory.p[index].element[rs][cs].value;
							mSoph.element[r + rs][c + cs].isFilled = 1;
						}
					}
					lastPos += 1;
					flag = 1;
				}

				else
				{
					temp = mString.substr(lastPos, 3);
					//if trigonometric function
					if (temp == "sin" || temp == "cos" || temp == "tan" || temp == "sec" || temp == "cot"
						|| mString.substr(lastPos, 4) == "cose")
					{
						temp = mString.substr(lastPos, mString.find(')', lastPos) - lastPos + 1);
						//didn't handle if there are brackets inside the asdsin(())
						//tempM = Trig(temp);
						for (int rs = 0; rs < tempM.rows; rs++)
						{
							for (int cs = 0; cs < tempM.columns; cs++)
							{
								mSoph.element[r + rs][c + cs].value = tempM.element[rs][cs].value;
								mSoph.element[r + rs][c + cs].isFilled == 1;
							}
						}
						lastPos += temp.length();
						flag = 1;
					}
					//if rand
					else if (temp == "ran")
					{
						temp = mString.substr(lastPos + 4, mString.find(')', lastPos) - lastPos + 1);
						//tempM = rand(temp)
						for (int rs = 0; rs < tempM.rows; rs++)
						{
							for (int cs = 0; cs < tempM.columns; cs++)
							{
								mSoph.element[r + rs][c + cs].value = tempM.element[rs][cs].value;
								mSoph.element[r + rs][c + cs].isFilled == 1;
							}
						}
						lastPos += temp.length();
						flag = 1;
					}
					//if eye
					else if (temp == "eye")
					{
						temp = mString.substr(lastPos + 3, mString.find(')', lastPos) - lastPos + 1);
						//tempM = eye(temp)
						for (int rs = 0; rs < tempM.rows; rs++)
						{
							for (int cs = 0; cs < tempM.columns; cs++)
							{
								mSoph.element[r + rs][c + cs].value = tempM.element[rs][cs].value;
								mSoph.element[r + rs][c + cs].isFilled == 1;
							}
						}
						lastPos += temp.length();
						flag = 1;
					}
					//if zeroes
					else if (temp == "zer")
					{
						temp = mString.substr(lastPos + 6, mString.find(')', lastPos) - lastPos + 1);
						//tempM = rand(temp)
						for (int rs = 0; rs < tempM.rows; rs++)
						{
							for (int cs = 0; cs < tempM.columns; cs++)
							{
								mSoph.element[r + rs][c + cs].value = tempM.element[rs][cs].value;
								mSoph.element[r + rs][c + cs].isFilled == 1;
							}
						}
						lastPos += temp.length();
						flag = 1;
					}
					//if ones
					else if (temp == "one")
					{
						temp = mString.substr(lastPos + 4, mString.find(')', lastPos) - lastPos + 1);
						//tempM = rand(temp)
						for (int rs = 0; rs < tempM.rows; rs++)
						{
							for (int cs = 0; cs < tempM.columns; cs++)
							{
								mSoph.element[r + rs][c + cs].value = tempM.element[rs][cs].value;
								mSoph.element[r + rs][c + cs].isFilled == 1;
							}
						}
						lastPos += temp.length();
						flag = 1;
					}
				}
			}
			//if [ 1 2 3]
			else if (temp[0] == '[')
			{
				OBCounter ++;
			}
			else if (temp[0] == ']')
			{
				OBCounter--;
			/*	if (OBCounter == 0)
				{
					OBColumnCounter[OBCounter] = 0;
					OBRowCounter[OBCounter] = 0;
				}*/
			}
			//if 2.3
			else if ((int(temp[0]) <= 57) && (int(temp[0]) >= 48))
			{

				int spacePos = mString.find(' ', lastPos)
					, semicolumnPos = mString.find(';', lastPos)
					, CBPos = mString.find(']', lastPos);
				//Because the separators inside [] are numerous
				if ((spacePos < semicolumnPos) && (spacePos < CBPos))
				{
					temp = mString.substr(lastPos, spacePos - lastPos);
				}
				else if ((semicolumnPos < spacePos) && (semicolumnPos < CBPos))
				{
					temp = mString.substr(lastPos, semicolumnPos - lastPos);
				}
				else
				{
					temp = mString.substr(lastPos, CBPos - lastPos);
				}

				stringstream ss;
				ss << temp;
				double value;
				ss >> value;
				mSoph.element[r+OBRowCounter[OBCounter]][c+ OBColumnCounter[OBCounter]].value = value;
				mSoph.element[r+OBRowCounter[OBCounter]][c+ OBColumnCounter[OBCounter]].isFilled = 1;

				if ((spacePos < semicolumnPos) && (spacePos < CBPos))
				{
					if (OBCounter != 0)
					{
						OBColumnCounter[OBCounter]++;//walking through the inner matrix
						c--;//freezing c as it will increase by one the next loop
					}
					lastPos = spacePos + 1;
				}
				else if ((semicolumnPos < spacePos) && (semicolumnPos < CBPos))
				{
					if (OBCounter != 0)
					{
						OBRowCounter[OBCounter]++;//walking through the inner matrix
						OBColumnCounter[OBCounter] = 0;//reseting column to start position
					}

					lastPos = semicolumnPos + 1;
				}
				else// ]
				{
					if (OBCounter != 0)
					{
						OBColumnCounter[OBCounter] = 0;//reseting both dimensions to the start position
						OBRowCounter[OBCounter] = 0;
					}

					lastPos = CBPos;//I want to start from the ]
				}
				flag = 1;
			}
			if (flag == 0)//if the character im on now is rubish ( space , etc...)
			{
				lastPos += 1;
				c--;
			}
			flag = 0;
		}
	}
}
